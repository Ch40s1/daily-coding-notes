<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <main>
            <nav>
                <button><a href="../../index.html">Home</a></button>
                <button><a href="../tree.html">Back</a></button>
            </nav>
            <h1>Big O</h1>
            <p>
                Big O notation is a way to describe the efficiency of an
                algorithm. It is a way to describe how the runtime of an
                algorithm grows as the input size grows and worst case scenario
                of an algorithm.
            </p>

            <div>
                <h2>Calculating Complexity</h2>
                <p>
                    One way that I found help me remeber this is to think of it
                    like a regular equation in math. It is written O(n) where n
                    is a variable not a specific number. Meaning it could be any
                    letter, they just chose this to be the letter we use.<br />
                </p>
                <p>
                    When trying to figure out time complexity for your
                    algorithm, think about the operations inside. For instance,
                    take this
                </p>
                <pre>
                    <code>
                        def find_length(nums):
                            max_length = 0
                            for num of nums:
                            max_length += 1
                    </code>
                </pre>
                <p>
                    This example function finds the length of the array nums and
                    adds it to the total. When trying to calculate the
                    complexity we need to look at the how the number of
                    operations changes as the input changes. So this means that
                    if we have one number in the array then the function will be
                    done in one step. Now if we increase the numbers in the
                    array then the number of steps till it is done will depend
                    of the number of items in the array. So if the array has "n"
                    elements then the loop will execute "n" times. Why? does the
                    initialization of the variable doesnt matter? well this
                    confused me at first. The simplest explanation is because
                    the number iterations that go one depend on nums, not the
                    variable. But, if you're curious then it is O(1) meaning it
                    is super fast and does not affect anything
                </p>
                <h3>Rules for complexity</h3>
                <ul>
                    <li>Ignore constants</li>
                    <li>
                        consider the complexity as the variables tend to
                        infinity
                    </li>
                    <li>Choose the worst case scenario</li>
                </ul>
                <p>
                    Why ignore constants, well because we are going to infinity
                    is what I learned. Think about this, if we add 500 to n so
                    "n + 500" at 0 it is 500 at 1 it is 1000 and so on. Plot the
                    data to inifinity and we see that the complexity will be
                    increasing linearly. So it is 0(n). One thing that I couldnt
                    get at first is the worst case scenario. The idea is that at
                    its worst it will be this, It gives you a better
                    representation of the "worst case" at makes more sence when
                    you start solving the questions.
                </p>
            </div>
            <section>
                <h3>Calculating Time complexity</h3>
                <div>
                    <pre>
                        <code>
                            for (int num: arr) {
                                print(num)
                            }
                        </code>
                    </pre>
                    <p>
                        We have gone over this but the is it O(n) because the
                        print cost O(1) and the loop is O(n) so O(1 * n) = O(n)
                    </p>
                    <pre><code>
                        for (int num: arr) {
                            for (int i = 0; i &lt; 500000; i++) {
                                print(num);
                            }
                        }
                    </code></pre>

                    <p>
                        This one has two loops, the outer one loops for the
                        length of the arr, and the inner one prints 500k
                        statements. So the algorithm print 500k statements for
                        every element of the array. Looking at it we can analyse
                        it as the outher loop O(n), the inner loop is O(500k)
                        the print is O(1). So O(n * 500k). We then ignore
                        constants so it is O(n).
                    </p>
                    <pre><code>
                        for (int num: arr) {
                            for (int num2: arr) {
                                print(num * num2)
                            }
                        }
                    </code></pre>
                    <p>
                        This one has two loops both loop n times O(n). Then it
                        has a pirnt and multiplication which are both O(1). So
                        O(n * n) = O(n^2)
                    </p>
                </div>
            </section>
            <img
                src="../../img/timeComplexityChart.png"
                alt="time complexity chart"
                desc
            />
            <p>
                I like this image it shows how fast the algorithms are
                <a
                    href="https://www.freecodecamp.org/news/big-o-cheat-sheet-time-complexity-chart/"
                    target="_blank"
                >
                    Link to image</a
                >
            </p>
            <div>
                <h3>Different time complexities; fastest to slowest</h3>
                <ol>
                    <li>
                        <strong>O(1):</strong> Constant time. The runtime does
                        not depend on the input size. An example is accessing an
                        element in an array by index.
                    </li>
                    <li>
                        <strong>O(log n):</strong> Logarithmic time. This means
                        that somewhere in your algorithm, the input is being
                        reduced by a percentage at every step. A good example is
                        binary search, which is a searching algorithm that runs
                        in O(log n) time. With binary search, we initially
                        consider the entire input (n elements). After the first
                        step, we only consider n / 2 elements. After the second
                        step, we only consider n / 4 elements, and so on. At
                        each step, we are reducing our search space by 50%,
                        which gives us a logarithmic time complexity.
                    </li>
                    <li>
                        <strong>O(n):</strong> Linear time. The runtime grows
                        linearly with the input size. An example is a simple
                        loop that runs through all elements in an array.
                    </li>
                    <li>
                        <strong>O(n log n):</strong> Linearithmic time. This
                        complexity is seen in algorithms that break the problem
                        into smaller subproblems, solve them independently, and
                        combine the results. A common example is the merge sort
                        algorithm.
                    </li>
                    <li>
                        <strong>O(n^2):</strong> Quadratic time. The runtime
                        grows quadratically with the input size. This is common
                        in algorithms with nested loops, where each loop runs n
                        times. An example is the bubble sort algorithm.
                    </li>
                    <li>
                        <strong>O(2^n):</strong> Exponential time. The runtime
                        grows exponentially with the input size. An example is
                        the recursive solution to the Fibonacci sequence, where
                        each call spawns two more calls.
                    </li>
                    <li>
                        <strong>O(n!):</strong> Factorial time. The runtime
                        grows factorially with the input size. This is seen in
                        algorithms that generate all permutations of a set, such
                        as the brute-force solution to the traveling salesman
                        problem.
                    </li>
                </ol>
            </div>
            <div>
                <!-- Here I will have exmaples to solve,
               would like to have one for each -->
                <h4>Examples:</h4>
                <ul>
                    <li>Constant time: O(1). Usually a single operation like accessing a item from a list</li>
                    <li>Linear time: O(n). Usually a loop that increases linearly with the size of the input</li>
                    <li>Logarithm time: O(logn) Depends on half the input size or when the input size decreases on each iteration.</li>
                    <li>Quadratic time: O(n^2). Output will be mush higher given a small input size.</li>
                    <li>O(n + m). Usually two loops that iterate over a set number of elements</li>
                    <li>Exponential time: O(2^n). Output doubles. Fibonacci sequence is a good example</li>
                </ul>
            </div>
        </main>
    </body>
</html>
